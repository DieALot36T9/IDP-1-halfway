Project: Simple Online eBook Reader
1. Project Overview

This document outlines the requirements for building a simple CRUD (Create, Read, Update, Delete) web application for an online eBook reader. The primary goal is to create a functional school project with a clear and simple architecture, avoiding complex frameworks and libraries. The application will have two distinct user roles: Users (readers) and Publishers.
2. Core Directives & Constraints

This project must adhere to the following constraints without exception:

    No Frameworks:

        Backend: Must be built using pure Python 3. Do not use frameworks like Flask, Django, FastAPI, etc. Use only the built-in http.server and json modules for the web server and API.

        Frontend: Must be built using pure, vanilla JavaScript (ES6+), HTML5, and CSS3. Do not use frameworks or libraries like React, Angular, Vue, jQuery, or Bootstrap.

    Database: The only database to be used is Oracle Database 21c XE. All database interactions from Python must use the oracledb library.

    Simplicity is Key: The entire codebase should be written with beginner-level syntax.

        No Password Hashing: For this project, passwords will be stored and handled as plain text. Do not use hashlib, secrets, or any other hashing/encryption library.

        No Complex Dependencies: Avoid introducing any external Python or JS libraries other than those explicitly listed (oracledb, pdf.js).

    Architecture: The application must be a Single Page Application (SPA). A single index.html file will serve as the shell, and JavaScript will dynamically render all content.

3. Technology Stack

    Backend: Python 3.x

    Web Server: Python's built-in http.server module

    Database: Oracle Database 21c XE

    Python-DB Connector: oracledb library

    Frontend: HTML5, CSS3, JavaScript (ES6+)

    PDF Viewer: PDF.js library

4. File & Directory Structure

The project must be organized using the following structure:

online-ebook-reader/
│
├── server.py              # Main web server, request router, and API endpoint logic.
├── database.py            # All database connection and query functions.
│
├── templates/
│   └── index.html         # The single HTML file shell for the SPA.
│
└── static/
    ├── css/
    │   └── style.css      # All custom styling.
    │
    ├── js/
    │   ├── main.js        # All frontend JavaScript logic.
    │   └── pdfjs/         # Directory for the PDF.js library files.
    │
    └── uploads/
        ├── covers/        # For uploaded book cover images.
        └── pdfs/          # For uploaded book PDF files.

5. Database Schema (Oracle DB)

The following tables must be created in the Oracle database.
Table 1: users

CREATE TABLE users (
    user_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    email VARCHAR2(100) UNIQUE NOT NULL,
    phone VARCHAR2(20),
    password VARCHAR2(100) NOT NULL,
    subscription_end_date DATE,
    session_token VARCHAR2(255) UNIQUE,
    token_expiry TIMESTAMP
);

Table 2: publishers

CREATE TABLE publishers (
    publisher_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    email VARCHAR2(100) UNIQUE NOT NULL,
    phone VARCHAR2(20),
    address VARCHAR2(255),
    description VARCHAR2(1000),
    image_path VARCHAR2(255),
    password VARCHAR2(100) NOT NULL,
    session_token VARCHAR2(255) UNIQUE,
    token_expiry TIMESTAMP
);

Table 3: books

CREATE TABLE books (
    book_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(255) NOT NULL,
    author_name VARCHAR2(100),
    description VARCHAR2(2000),
    category VARCHAR2(50),
    cover_path VARCHAR2(255),
    pdf_path VARCHAR2(255) NOT NULL,
    publisher_id NUMBER,
    CONSTRAINT fk_publisher
        FOREIGN KEY(publisher_id)
        REFERENCES publishers(publisher_id)
        ON DELETE CASCADE
);

Table 4: bookmarks

CREATE TABLE bookmarks (
    user_id NUMBER,
    book_id NUMBER,
    PRIMARY KEY (user_id, book_id),
    FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    FOREIGN KEY(book_id) REFERENCES books(book_id) ON DELETE CASCADE
);

Table 5: reading_history

CREATE TABLE reading_history (
    history_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id NUMBER,
    book_id NUMBER,
    last_read_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE (user_id, book_id),
    FOREIGN KEY(user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    FOREIGN KEY(book_id) REFERENCES books(book_id) ON DELETE CASCADE
);

Book Categories

The category field in the books table should be populated from a fixed list. The publisher will select one of these when adding/editing a book.

    BCS Preliminary

    Bank Recruitment

    Government Jobs (Non-Cadre)

    NTRCA (Teacher Registration)

    Primary School Teacher Recruitment

    General Knowledge

    Language & Literature

6. Feature Set
User Features

    Authentication:

        Register (Name, Email, Phone, Password).

        Login (Email, Password).

    Profile Management:

        View profile details.

        Edit Name and Password.

    Subscription:

        A placeholder "Subscribe" button that simulates a 1-month subscription by setting subscription_end_date.

        View current subscription status.

    Book Interaction:

        Browse and search all books.

        View book details (Cover, Description, Name, Author, Publisher).

        Read a book (opens the PDF in the PDF.js viewer).

        Add/Remove books from a personal bookmark list.

        View a "Last Read Books" list, ordered by the most recently opened.

Publisher Features

    Authentication:

        Register (Name, Image, Email, Phone, Address, Description, Password).

        Login (Email, Password).

    Book Management (CRUD):

        Add new books (upload Cover Image, PDF file, and enter details).

        View a list of all books they have personally published.

        Edit the details of their published books.

        Remove their published books.

    Browsing:

        Browse/search all books in the library but cannot read them (the "Read" button should be disabled or hidden).

    Publisher Page:

        A public-facing page that users can view, displaying the publisher's Name, Image, Address, Phone, Email, and Description.

7. Application Architecture & Logic Flow
Backend (server.py & database.py)

    server.py will run a simple HTTPServer. It will parse the request path and method (GET/POST).

        Paths starting with /api/ are API calls.

        Paths starting with /static/ serve files from the static directory.

        All other paths serve the main templates/index.html.

    For API calls, server.py will call functions in database.py to interact with Oracle DB.

    For file uploads (book covers, PDFs), server.py will handle multipart/form-data requests, save the files to the correct subdirectory within static/uploads/, and pass the generated file paths to the database function.

    All data returned from the API must be in JSON format.

Frontend (main.js)

    The frontend will operate as an SPA, using the URL hash for routing (e.g., /#login, /#register, /#dashboard).

    The main.js file will contain an event listener for hashchange to render the appropriate "page".

    All content will be dynamically generated with JavaScript and inserted into a single container element, like <div id="app"></div> in index.html.

    All user interactions (button clicks, form submissions) will be handled by event listeners that trigger fetch() calls to the backend API.

    The fetch() API will be used for all communication with the Python server.

Authentication Flow

    User/Publisher logs in via a form.

    main.js sends a POST request to /api/login with email and password.

    server.py verifies credentials using a function in database.py.

    If valid, database.py generates a random session token, saves it to the appropriate user/publisher table with an expiry timestamp, and returns it.

    server.py sends the token back to the client in the JSON response.

    main.js receives the token and stores it in the browser's localStorage.

    For all subsequent authenticated API requests, main.js must retrieve the token from localStorage and include it in the Authorization HTTP header (e.g., Authorization: Bearer <token>).

    server.py will validate this token on every request that requires authentication.
